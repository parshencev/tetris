/*
  Поворот матрицы на 90 градусов по/против часовой стрелки.
  Принимает массив массивов и число вращений.
  Отрицательное число вращений поворачивает матрицу против часовой стрелки
*/

// одинарный поворот матрицы по/против часовой стрелки на 90 градусов. Принимает матрицу и направление поворота
const rotate = (matrix, direction) => {
  const height = matrix.length, // высота матрицы
        width = Math.max(...matrix.map(({ length }) => length)), // ширина матрицы
        rotatedMatrix = []; // будущая преобразованная матрица

  // цикл по ширине матрицы
  for (let x = 0; x < width; x++) {
    rotatedMatrix.push([]); // добавление новой строки в преобразованную матрицу

    // цикл по высоте матрицы
    for (let y = 0; y < height; y++) {
      // добавление ячейки в строку из переданной матрицы
      rotatedMatrix[x].push(
        matrix[
          direction === "right" ? height - 1 - y : y // начиная с последней строки если по часовой и начиная с первой если против
        ][
          direction === "right" ? x : width - 1 - x // начиная с последней ячейки в строке если против часовой и с первой если по часовой
        ]
      );
    }
  }

  return rotatedMatrix; // возврат преобразованной мастрицы
};

module.exports = (matrix, times) => {
  const direction = times > 0 ? "right" : "left"; // определение направления вращения

  times = Math.abs(times); // получаем только положительное кол-во вращений
  times > 4 && (times %= 4); // если кол-во вращений больше 4-х то делим его на 4 без остатка

  if (times === 0) { // если кол-во вращений равно 0
    return matrix; // возвращаем матрицу как она передана
  } else { // если больше 0
    let newMatrix = [...matrix]; // копируем матрицу

    for (let t = 0; t < times; t++) { // выполняем цикл по кол-ву вращений
      newMatrix = rotate(newMatrix, direction); // вращаем скопированную/преобразованную матрицу на 1 раз
    };

    return newMatrix; // возвращаем преобразованную матрицу
  }
};



